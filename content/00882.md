

`mvn spring-boot:build-image`/`gradle bootBuildImage`あるいはPaketo Buildpackで作成したJavaのコンテナイメージはデフォルトではJREが使われ、JDKは含まれていません。
そのため、`jstack`や`jcmd`などの診断用のツールがコンテナには含まれません。
また、最近のSpring BootではBuilderとして[Paketo Noble Java Tiny Builder](https://github.com/paketo-buildpacks/builder-noble-java-tiny)を使用します。
このBuilderのStackは[ubuntu-noble-run-tiny](https://github.com/paketo-buildpacks/ubuntu-noble-base-images/tree/main/stacks/noble-tiny-stack/run)であり、scratchに必要最小限のファイルを追加したイメージです。
すなわち、このイメージには`bash`や`sh`などのシェルも含まれていません。
これはイメージの軽量化および、マルチアーキテクチャのサポートのためには必要なことですが、トラブルシューティングの際に不便になることがあります。

このBuilderを使いつつ、トラブルシュートもできるようにしたいですよね。 まずは、`jcmd`でスタックトレースやヒープダンプを取れるようにしたいです。
そこで便利なのが[Paketo Buildpack for Jattach](https://github.com/paketo-buildpacks/jattach)です。

[jattach](https://github.com/jattach/jattach)は実行中のJavaプロセスに動的に接続して操作を実行するための軽量なコマンドラインツールです。
jmap、jstack、jcmd、jinfoの機能が一つのバイナリにまとまっています。
Paketo Buildpack for Jattachはこのjattachをコンテナイメージに追加するBuildpackです。

Paketo Buildpack for Jattachはデフォルトでは有効になっていませんが、ビルド時の環境変数`BP_JATTACH_ENABLED`を`true`に設定することで有効化できます。
Mavenの場合は次のような設定で`jattach`がイメージに含まれるようになります。

```xml
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <configuration>
          <image>
            <env>
              <BP_JATTACH_ENABLED>true</BP_JATTACH_ENABLED>
            </env>
          </image>
        </configuration>
        <!-- ... -->
      </plugin>
```

これでコンテナ内で`jattach`を使ってスタックトレースやヒープダンプを取れるようになります。`jattach`のパスは`/layers/paketo-buildpacks_jattach/jattach/bin/jattach`です。

KubernetesのPod内でヒープダンプを取る例を示します。`1`はJavaプロセスのPIDです。

```bash
NAMESPACE=...
POD_NAME=...
kubectl exec -n $NAMESPACE $POD_NAME -ti -- /layers/paketo-buildpacks_jattach/jattach/bin/jattach 1 dumpheap /tmp/heapdump.hprof
```

次のようなログが出力されるでしょう。

```
Connected to remote JVM
JVM response code = 0
Dumping heap to /tmp/heapdump.hprof ...
Heap dump file created [69843865 bytes in 0.294 secs]
```

これで`/tmp/heapdump.hprof`にヒープダンプが保存されます。

ではこのヒープダンプファイルを次のコマンドで、ローカルにコピーしましょう。

```bash
kubectl cp -n $NAMESPACE/$POD_NAME:/tmp/heapdump.hprof ./
```

しかし、次のようなエラーが出てコピーできません。`tar`コマンドがPod内に存在しないためです。

```
time="2025-12-18T09:58:08Z" level=error msg="exec failed: unable to start container process: exec: \"tar\": executable file not found in $PATH"
command terminated with exit code 255
```

では代わりに`cat`コマンドでヒープダンプを標準出力に出し、ローカルで受け取る方法を試みましょう。

```bash
kubectl exec -n $NAMESPACE $POD_NAME -- cat /tmp/heapdump.hprof > ./heapdump.hprof
```

しかし、次のようなエラーが出てコピーできません。`cat`コマンドもPod内に存在しないためです。

```
time="2025-12-18T10:00:09Z" level=error msg="exec failed: unable to start container process: exec: \"cat\": executable file not found in $PATH"
command terminated with exit code 255
```

このように、Paketo Noble Java Tiny Builderを使って作成したコンテナイメージにはシェルも含まれていないため、`kubectl cp`や`kubectl exec`でファイルをコピーすることができません。

では、どうすればよいでしょうか？実はJREにはあまり知られていないコマンドとして`jwebserver`があります。`jwebserver`は小さなHTTPサーバーで、特定のディレクトリを公開することができます。

次のコマンドで、Pod内で`jwebserver`を起動し、`/tmp`ディレクトリをポート8000で公開します。

```bash
kubectl exec -n $NAMESPACE $POD_NAME -ti -- /layers/paketo-buildpacks_bellsoft-liberica/jre/bin/jwebserver -b 0.0.0.0 -p 8000 -d /tmp 
```

別ターミナルでローカルの8000ポートをPodの8000ポートに転送します。

```bash
NAMESPACE=...
POD_NAME=....
kubectl port-forward -n $NAMESPACE $POD_NAME 8000:8000
```

さらに別ターミナルで、`wget`コマンドでヒープダンプファイルをダウンロードします。

```bash
wget http://localhost:8000/heapdump.hprof
```

これで無事ヒープダンプファイルをローカルに保存できました。