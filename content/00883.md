---
title: InstanceSourceでJavaのシステム時刻の作成を抽象化しテスタビリティをあげる
---

Javaでシステム時刻(現在時刻)を取得する際に`Instant.now()`や`LocalDateTime.now()`などを使うことが一般的です。しかし、これらのメソッドはシステムクロックに依存しているため、テスト時にシステム時刻を制御することが難しくなります。
システム時刻の作成を抽象化するためのクラスとしてJDKには

* `java.time.Clock` - JDK 8で追加
* `java.time.InstantSource` - JDK 17で追加

が用意されています。`Clock`と`InstantSource`との違いは前者はタイムゾーンを保持していることです。`InstantSource`は`java.time.Instant`生成のみを扱います。
また、`Clock`はabstractクラスですが、`InstantSource`はinterfaceです。


`Clock`を使う場合は、次のように日付・時刻を取得します。

```java
Clock clock = Clock.systemUTC();
Clock clock = Clock.systemDefaultZone();

Instant now = clock.instant();
OffsetDateTime now = OffsetDateTime.now(clock);
LocalDateTime now = LocalDateTime.now(clock);
LocalDate now = LocalDate.now(clock);
```

`InstantSource`を使う場合は、次のように時刻を取得します。

```java
InstantSource instanceSource = InstantSource.system();

Instant now = instanceSource.instant();
```

システム時刻（`Instant`）とユーザーのローカライゼーション（`ZoneId`）は本来別々の関心毎ですが、Clockではこれらが結合しています。
シンプルにシステム時刻だけを取得するインタフェースがあるべきだ、ということでJDK 17で`InstantSource`が追加されました。
より詳細な経緯は[こちら](https://mail.openjdk.org/pipermail/core-libs-dev/2021-May/077213.html)から確認できます。

以下では`InstantSource`を使った例を示しますが、`Clock`は`InstantSource`インタフェースを実装しており、`Clock`のインスタンスは`InstantSource`としても利用できます。
おそらく、日本国内でのみ利用されるシステムのように、タイムゾーンがJ固定されるケースでは`Clock`を使った方が`LocalDate`の生成など便利な場合が多いかもしれません。
なお、`InstanceSource`から`Clock`ヘの変換は次のように行えます。

```java
Clock clock = instantSource.withZone(ZoneId.systemDefault());
```

さて、実際のアプリケーションにおいては`InstanceSource`はDependency Injection(DI)コンテナなどを使って注入することが一般的です。例えば、Spring Bootを使っている場合は次のようにBean定義を行います:


```java
import java.time.InstantSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false)
class AppConfig {

	@Bean
	InstantSource instantSource() {
		return InstantSource.system();
	}

}
```

テストなどで、固定の時刻を返却したい場合は、次のように`InstanceSource`を上書きできます。

```java
	@Bean
	@Primary
	InstantSource fixedInstantSource() {
		return InstantSource.fixed(Instant.parse("2025-12-01T00:00:00Z"));
	}
```

`InstantSource`はFunctionall Interfaceなので、次のようにラムダ式で実装することも可能です。

```java
	@Bean
	InstantSource instantSource() {
		return () -> Instant.parse("2025-12-01T00:00:00Z");
	}
```


`Instance`を作成したい場合は、`InstanceSource`をinjectして利用します。

```java
@Service
public class MessageService {
	private final InstantSource instantSource;

	public MessageService(InstantSource instantSource) {
		this.instantSource = instantSource;
	}

	public Mesage createMessage(String content) {
		Instant now = instantSource.instant();
		return new Message(content, now);
	}
}
```

`LocalDate`を作成したい場合は、次のようにします。

```java
		ZoneId zoneId = ZoneId.of("Asia/Tokyo");
		LocalDate now = instantSource.instant().atZone(zoneId).toLocalDate();
````

あるいは、injectionのタイミングでタイムゾーンを設定するかもしれません。

```java
@Service
public class MessageService {
	private final Clock clock;

	public MessageService(InstantSource instantSource) {
		this.clock = instantSource.withZone(ZoneId.of("Asia/Tokyo"));
	}

	public Mesage createMessage(String content) {
		LocalDate now = LocalDate.now(this.clock);
		return new Message(content, now);
	}
}
```

ユーザー毎によって`ZoneId`を変えたいという場合には`org.springframework.format.datetime.standard.DateTimeContextHolder`でスレッドローカルに`ZoneId`を保持する方法などもあります。

エンタープライズ開発でよく見られるのはシステム時刻をデータベースから取得するケースで。結合テストなので、特定の時間のテストを行いたい場合などに有効です。
データベースからシステム時刻を取得する例を示します。ここではPostgreSQLを前提とします。

次のように、特定のシステム時刻を設定するテーブがあるとします。

```sql
CREATE TABLE IF NOT EXISTS system_date
(
    date_time TIMESTAMP WITH TIME ZONE
);
```

このテーブルにデータが存在する場合はその日時を、存在しない場合はデータベースの現在時刻をシステム時刻として取得する例を示します。

```java
import java.time.InstantSource;
import java.time.OffsetDateTime;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.simple.JdbcClient;

@Configuration(proxyBeanMethods = false)
class AppConfig {

	@Bean
	InstantSource jdbcInstantSource(JdbcClient jdbcClient) {
		return () -> jdbcClient.sql("SELECT COALESCE((SELECT date_time FROM system_date), NOW())")
			.query(OffsetDateTime.class)
			.single()
			.toInstant();
	}

}
```

あるいは、データベース上に、現在時刻からのオフセット(分)を保持するテーブルがある場合は、次のように実装できます。

```sql
CREATE TABLE system_date
(
    offset_minites INT NOT NULL
);
```

```java

import java.time.InstantSource;
import java.time.OffsetDateTime;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.simple.JdbcClient;

@Configuration(proxyBeanMethods = false)
class AppConfig {

	@Bean
	InstantSource jdbcInstantSource(JdbcClient jdbcClient) {
		return () -> jdbcClient.sql("""
				SELECT
				    NOW() + MAKE_INTERVAL(
				        mins => COALESCE(MAX(offset_minites), 0)
				    )
				FROM
				    system_date
				""").query(OffsetDateTime.class).single().toInstant();
	}

}
```

これらを使うことで、アプリケーションを起動し直すことなく、データベースの内容を変更するだけでシステム時刻を変更できるようになります。

---

TODO: まとめを書く