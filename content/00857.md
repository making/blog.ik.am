---
title: VMware Tanzu Gemfire on Kubernetes 2.5をインストールするメモ
tags: ["Gemfire", "Tanzu", "Kubernetes", "Helm"]
categories: ["Middleware", "DistributedSystem", "InMemoryDataGrid", "Gemfire"]
---

[Tanzu Gemfire on Kubernetes 2.5](https://techdocs.broadcom.com/us/en/vmware-tanzu/data-solutions/tanzu-gemfire-on-kubernetes/2-5/gf-k8s/index.html)をインストールしてみます。

### Tanzu GemFire on Kubernetes Docker Registryのアクセストークン取得

Broadcom Supportにログインして、[Tanzu GemFire](https://support.broadcom.com/group/ecx/productdownloads?subfamily=VMware%20Tanzu%20GemFire)のページからアクセストークンを取得してください。


![image](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/1852/4b0baaaf-45e2-4db4-ac19-bec298decb6f.png)
![image](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/1852/1366b9fa-127c-4ad5-97ab-d2277bfbdc6e.png)


次のコマンドで`registry.packages.broadcom.com`にログインします。認証情報を自分のものに置き換えてください。

```bash
BC_SUPPORT_USERNAME=toshiaki.maki@broadcom.com
BC_SUPPORT_PASSWORD=eyJ2ZX*************************************
docker login registry.packages.broadcom.com -u ${BC_SUPPORT_USERNAME} -p ${BC_SUPPORT_PASSWORD}
```

```
WARNING! Using --password via the CLI is insecure. Use --password-stdin.
Login Succeeded
```

ただし、このトークンは有効期限があり、期限が切れるたびにローテートするのが面倒くさいので、今回はこのRegistryから直接Pullするのではなく、ghcr.ioにリロケートした上で使用することとします。

### Helm Chartとコンテナイメージをghcr.ioへリロケート


次のコマンドで`ghcr.io`にログインします。認証情報を自分のものに置き換えてください。`ghcr.io`以外のRegistryでも良いです。

```bash
GHCR_USERNAME=makingx@gmail.com
GHCR_PASSWORD=ghp_*****************
docker login ghcr.io -u ${GHCR_USERNAME} -p ${GHCR_PASSWORD}
```

リロケートには[imgpkg](https://carvel.dev/imgpkg/)を使用します。

```bash
imgpkg copy -i registry.packages.broadcom.com/tanzu-gemfire-for-kubernetes/gemfire-crd:2.5.0 --to-repo ghcr.io/making/tanzu-gemfire-for-kubernetes/gemfire-crd
imgpkg copy -i registry.packages.broadcom.com/tanzu-gemfire-for-kubernetes/gemfire-operator:2.5.0 --to-repo ghcr.io/making/tanzu-gemfire-for-kubernetes/gemfire-operator
```

リロケート後のHelm Chartにアクセスして設定可能なvaluesを確認します。

```bash
$ helm show values oci://ghcr.io/making/tanzu-gemfire-for-kubernetes/gemfire-operator --version 2.5.0
Pulled: ghcr.io/making/tanzu-gemfire-for-kubernetes/gemfire-operator:2.5.0
Digest: sha256:6e6553b72dd5a6237c967676d6c88614982cfd31aefd44a94ecef587c916967a
controllerImage: registry.packages.broadcom.com/tanzu-gemfire-for-kubernetes/gemfire-controller:2.5.0
certManagerNamespace: cert-manager
```

`controllerImage`も次のコマンドで`registry.packages.broadcom.com`から`ghcr.io`にリロケートします。


```bash
imgpkg copy -i registry.packages.broadcom.com/tanzu-gemfire-for-kubernetes/gemfire-controller:2.5.0 --to-repo ghcr.io/making/tanzu-gemfire-for-kubernetes/gemfire-controller
```

### Tanzu GemFire on Kubernetesのインストール

Tanzu GemFire for KubernetesのCRDとOperatorをインストールします。

まずはKubernetesのNamespaceを作成し、Docker Registry (ghcr.io)のSecretを作成します。

```bash
kubectl create namespace gemfire-system
kubectl create secret docker-registry gemfire-registry-secret \
    --docker-server=ghcr.io \
    --docker-username=${GHCR_USERNAME} \
    --docker-password="${GHCR_PASSWORD}" \
    -n gemfire-system
```

次のコマンドでGemfire CRDをインストールします。

```bash
helm upgrade --install \
  -n gemfire-system \
  gemfire-crd \
  oci://ghcr.io/making/tanzu-gemfire-for-kubernetes/gemfire-crd \
  --version 2.5.0 \
  --set operatorReleaseName=gemfire-operator \
  --wait
```

次のコマンドでGemfire Operatorをインストールします。リロケート後のChartとコンテナイメージを指定します。

```bash
helm upgrade --install \
  -n gemfire-system \
  gemfire-operator \
  oci://ghcr.io/making/tanzu-gemfire-for-kubernetes/gemfire-operator \
  --version 2.5.0 \
  --set controllerImage=ghcr.io/making/tanzu-gemfire-for-kubernetes/gemfire-controller:2.5.0 \
  --set imagePullSecretName=gemfire-registry-secret \
  --wait
```

しばらくするとインストールが完了します。helm listでインストール状態を確認できます。

```bash
$ helm list -n gemfire-system
NAME            	NAMESPACE     	REVISION	UPDATED                             	STATUS  	CHART                 	APP VERSION
gemfire-crd     	gemfire-system	1       	2025-06-20 11:55:13.47622 +0900 JST 	deployed	gemfire-crd-2.5.0     	2.5.0      
gemfire-operator	gemfire-system	1       	2025-06-20 11:56:56.713258 +0900 JST	deployed	gemfire-operator-2.5.0	2.5.0 
```

次のコマンドで、Gemfire OperatorのPodの状態を確認します。

```bash
$ kubectl get pod -n gemfire-system 
NAME                                                 READY   STATUS    RESTARTS   AGE
gemfire-operator-controller-manager-c4d8dfd5-nx6p5   1/1     Running   0          2m42s
```

次のコマンドで、このGemfire Operatorで利用可能なカスタムリソースを確認します。

```bash
$ kubectl api-resources --api-group=gemfire.vmware.com 
NAME              SHORTNAMES   APIVERSION              NAMESPACED   KIND
gemfireclusters                gemfire.vmware.com/v1   true         GemFireCluster
```

### GemFireClusterの作成

Gemfire Operatorを使ってdemo namespaceにGemFireClusterインスタンスの作成します。

GemFireのコンテナイメージは別途指定する必要があり、これも先と同様に`ghcr.io`にリロケートしておきます。Operatorのバージョンと独立して、サポートされている最新のGemFireのコンテナイメージを使用することができます。
ここでは本稿執筆時点で最新のバージョンである10.1.3を使用します。

```bash
imgpkg copy -i registry.packages.broadcom.com/pivotal-gemfire/vmware-gemfire:10.1.3 --to-repo ghcr.io/making/pivotal-gemfire/vmware-gemfire
```

次のコマンドでnamespaceとdocker pull secretを作成します。

```bash
kubectl create namespace demo
kubectl create secret docker-registry gemfire-registry-secret \
    --docker-server=ghcr.io \
    --docker-username=${GHCR_USERNAME} \
    --docker-password="${GHCR_PASSWORD}" \
    -n  demo
```


次のコマンドでGemFireClusterインスタンスを作成します。Locator 2台、Server 3台の構成にします。

```yaml
cat <<EOF > /tmp/demo-gemfire.yaml
---
apiVersion: gemfire.vmware.com/v1
kind: GemFireCluster
metadata:
  name: demo
spec:
  image: ghcr.io/making/pivotal-gemfire/vmware-gemfire:10.1.3
  imagePullSecrets:
  - name: gemfire-registry-secret
  persistentVolumeClaim:
    deleteOnShutdown: true
  locators:
    replicas: 2
  servers:
    replicas: 3
    resources:
      requests:
        memory: 4Gi
      limits:
        memory: 4Gi
---
EOF

kubectl apply -f /tmp/demo-gemfire.yaml -n demo
```

> [!NOTE]
> `spec.persistentVolumeClaim.deleteOnShutdown`を`true`に設定すると、GemFireClusterが削除されたときにPersistentVolumeClaimも削除されます。
> デフォルトでは`false`になっているので、GemFireClusterを削除してもPersistentVolumeClaimは残ります。プロダクションでは、念の為`false`にしておくことが良いでしょう。


次のコマンドで、GemFireClusterの状態を確認します。

```bash
$ kubectl get gemfirecluster,sts,pod,pvc -n demo -owide
NAME                                     LOCATORS   SERVERS   CLUSTER IMAGE                                          OPERATOR VERSION
gemfirecluster.gemfire.vmware.com/demo   2/2        3/3       ghcr.io/making/pivotal-gemfire/vmware-gemfire:10.1.3   2.5.0

NAME                            READY   AGE     CONTAINERS   IMAGES
statefulset.apps/demo-locator   2/2     5m32s   locator      ghcr.io/making/pivotal-gemfire/vmware-gemfire:10.1.3
statefulset.apps/demo-server    3/3     4m9s    server       ghcr.io/making/pivotal-gemfire/vmware-gemfire:10.1.3

NAME                 READY   STATUS    RESTARTS   AGE     IP             NODE     NOMINATED NODE   READINESS GATES
pod/demo-locator-0   1/1     Running   0          5m32s   10.1.42.145    banana   <none>           <none>
pod/demo-locator-1   1/1     Running   0          5m32s   10.1.42.146    banana   <none>           <none>
pod/demo-server-0    1/1     Running   0          4m9s    10.1.42.147    banana   <none>           <none>
pod/demo-server-1    1/1     Running   0          4m9s    10.1.173.139   cherry   <none>           <none>
pod/demo-server-2    1/1     Running   0          4m9s    10.1.42.148    banana   <none>           <none>

NAME                                        STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE     VOLUMEMODE
persistentvolumeclaim/data-demo-locator-0   Bound    pvc-50d09d5f-bcac-4e74-889f-372fa212c05c   2Gi        RWO            nfs-csi        <unset>                 5m32s   Filesystem
persistentvolumeclaim/data-demo-locator-1   Bound    pvc-cd7d814a-d5e4-455c-b890-d88713778e7b   2Gi        RWO            nfs-csi        <unset>                 5m32s   Filesystem
persistentvolumeclaim/data-demo-server-0    Bound    pvc-baa12461-2220-4142-96d6-820a78a4379a   4Gi        RWO            nfs-csi        <unset>                 4m9s    Filesystem
persistentvolumeclaim/data-demo-server-1    Bound    pvc-423de0c1-782b-442d-8aeb-55909b14e9ab   4Gi        RWO            nfs-csi        <unset>                 4m9s    Filesystem
persistentvolumeclaim/data-demo-server-2    Bound    pvc-90253b95-16f4-4569-adba-9b568daa256a   4Gi        RWO            nfs-csi        <unset>                 4m9s    Filesystem
```

次のコマンドでLocatorのPod内でbashを実行します。

```bash
kubectl -n demo exec -it demo-locator-0 -- bash
```

Tanzu Gemfire on Kubernetesで作成されるGemfireクラスターはデフォルトでTLSが有効になっています。`/certs`ディレクトリにGemFireの証明書が作成されていることを確認します。

```bash
[root@demo-locator-0 data]# ls -l /certs
total 0
lrwxrwxrwx 1 root root 13 Jun 20 05:42 ca.crt -> ..data/ca.crt
lrwxrwxrwx 1 root root 19 Jun 20 05:42 keystore.p12 -> ..data/keystore.p12
lrwxrwxrwx 1 root root 15 Jun 20 05:42 password -> ..data/password
lrwxrwxrwx 1 root root 14 Jun 20 05:42 tls.crt -> ..data/tls.crt
lrwxrwxrwx 1 root root 14 Jun 20 05:42 tls.key -> ..data/tls.key
lrwxrwxrwx 1 root root 21 Jun 20 05:42 truststore.p12 -> ..data/truststore.p12
```

証明書のTruststoreとKeystoreのパスワードは、`/certs/password`に保存されています。これを使ってgfshでGemFireに接続します。

```bash
[root@demo-locator-0 data]# echo $(cat /certs/password)
rpUt17JjuLLoxN7S9CzRZ8WbwYqMaDjINTZ9OxetAU4=
```

`gfsh`を実行して、GemFireに接続します。

```bash
[root@demo-locator-0 data]# gfsh
/gemfire/bin/gfsh: line 36: tput: command not found
    _________________________     __
   / _____/ ______/ ______/ /____/ /
  / /  __/ /___  /_____  / _____  / 
 / /__/ / ____/  _____/ / /    / /  
/______/_/      /______/_/    /_/    10.1.3

Monitor and Manage Tanzu GemFire
gfsh>
```

`connect`コマンドを実行して、Locatorに接続します。ここでは、Locatorのホスト名とポート番号を指定します。`--trust-store`と`--key-store`オプションで証明書のパスを指定し、パスワードは先ほど確認したものを使用します。

```bash
connect --locator=demo-locator-0.demo-locator.demo.svc.cluster.local[10334] --trust-store=/certs/truststore.p12 --trust-store-password=rpUt17JjuLLoxN7S9CzRZ8WbwYqMaDjINTZ9OxetAU4= --key-store=/certs/keystore.p12 --key-store-password=rpUt17JjuLLoxN7S9CzRZ8WbwYqMaDjINTZ9OxetAU4=
```

以下の項目に対して、プロンプト上で入力を求められますが、全てデフォルトでEnterを押して進めます。

```
key-store-type(default: JKS): 
trust-store-type(default: JKS): 
ssl-ciphers(default: any): 
ssl-protocols(default: any): 
ssl-enabled-components(default: all):
```

これでGemFireに接続できました。以下のようなメッセージが表示されます：

```
Connecting to Locator at [host=demo-locator-0.demo-locator.demo.svc.cluster.local, port=10334] ..
Connecting to Manager at [host=demo-locator-0.demo-locator.demo.svc.cluster.local, port=1099] ..
Successfully connected to: [host=demo-locator-0.demo-locator.demo.svc.cluster.local, port=1099]

You are connected to a cluster of version 10.1.3.
```

なお、Pod内からは`connect --url=https://demo-locator.demo.svc.cluster.local:7070/gemfire/v1 --skip-ssl-validation`を実行しても接続できました。

`list members`コマンドで、GemFireのメンバー（LocatorとServer）が正しく起動していることを確認します：

```bash
gfsh>list members
Member Count : 5

     Name      |                                  Id                                  |  Type   | Status
-------------- | -------------------------------------------------------------------- | ------- | ------
demo-locator-0 | demo-locator-0(demo-locator-0:1:locator)<ec><v0>:60681 [Coordinator] | Locator | Ready
demo-locator-1 | demo-locator-1(demo-locator-1:1:locator)<ec><v1>:54760               | Locator | Ready
demo-server-0  | demo-server-0(demo-server-0:1)<v2>:42292                             | Server  | Ready
demo-server-1  | demo-server-1(demo-server-1:1)<v3>:56073                             | Server  | Ready
demo-server-2  | demo-server-2(demo-server-2:1)<v2>:57696                             | Server  | Ready
```

PARTITION_PERSISTENTタイプのRegionを作成し、冗長度1（各データが2つのServerに保存される）を設定します。その後、テストデータを追加します：


```bash
create region --name=demo --type=PARTITION_PERSISTENT --redundant-copies=1

put --region=/demo --key=aaa --value=1
put --region=/demo --key=bbb --value=2
put --region=/demo --key=ccc --value=3
put --region=/demo --key=ddd --value=4
put --region=/demo --key=eee --value=5
```

データが正しく保存されているかをクエリで確認します：

```bash
gfsh>query --query="SELECT * FROM /demo"
Result : true
Limit  : 100
Rows   : 5

Result
------
3
5
2
1
4
```

Podの外からGemFireに接続するために、Locatorの管理APIを公開します。ここではContourのHTTPProxyを使用して、[Upstream TLS](https://projectcontour.io/docs/1.32/config/upstream-tls/)の機能を使います。

次のコマンドで、Locatorの管理APIを公開するためのServiceとHTTPProxyを作成します。ここでは`projectcontoure` namespaceに作成されたCertificate`default-tls` (Let's Encryptによるワイルドカード証明書)が[TLSCertificateDelegation](https://projectcontour.io/docs/1.32/config/tls-delegation/#tls-certificate-delegation)で公開されている前提です。


```yaml
cat <<EOF > /tmp/demo-locator-management-api.yaml
apiVersion: v1
kind: Service
metadata:
  name: demo-locator-management-api
  namespace: demo
  annotations:
    projectcontour.io/upstream-protocol.tls: "7070"
spec:
  type: ClusterIP
  ports:
  - name: locator-management-api
    port: 7070
  selector:
    gemfire.vmware.com/app: demo-locator
---
apiVersion: projectcontour.io/v1
kind: HTTPProxy
metadata:
  name: demo-locator-management-api
  namespace: demo
spec:
  virtualhost:
    fqdn: demo-locator.lan.ik.am
    tls:
      secretName: projectcontour/default-tls
  routes:
  - services:
    - name: demo-locator-management-api
      port: 7070
      validation:
        caSecret: demo-cert
        subjectName: demo-locator.demo.svc.cluster.local
---
EOF

kubectl apply -f /tmp/demo-locator-management-api.yaml
```

これでPodの外から`gfsh`を使って次のようにGemFireに接続できるようになります。

```
connect --url=https://demo-locator.lan.ik.am/gemfire/v1
```


### JavaアプリケーションからGemFireに接続

[こちらの記事](/entries/854)と同様に、 https://github.com/making/demo-gemfire のサンプルアプリからGemfireに接続してみます。ソースコードはGithubをみてください。

まずはgfshでRegionを作成します：

```bash
create region --name=Customers --type=PARTITION_PERSISTENT --redundant-copies=1
```

Tanzu Gemfire on Kubernetesでは自動的に次のdisk storeとpdxの設定が行われているので、追加設定なして`PARTITION_PERSISTENT`タイプのRegionでPDXを使用することができます。

```xml
    <disk-store name="pdxmetadata">
        <disk-dirs>
            <disk-dir>/data/pdxmetadata</disk-dir>
        </disk-dirs>
    </disk-store>
    <pdx read-serialized="true" persistent="true" disk-store-name="pdxmetadata"/>
```

デモアプリをK8s上にデプロイするために、https://github.com/stakater/application の汎用的なHelm Chartを使用します。

```bash
helm repo add stakater https://stakater.github.io/stakater-charts
```

Helm用のvaluesファイルを作成します。`env`に設定する内容は次のドキュメントを参考にしました。

* https://techdocs.broadcom.com/us/en/vmware-tanzu/data-solutions/tanzu-gemfire-on-kubernetes/2-5/gf-k8s/app-dev.html
* https://techdocs.broadcom.com/us/en/vmware-tanzu/data-solutions/tanzu-gemfire-on-kubernetes/2-5/gf-k8s/security-tls-security.html

```yaml
cat <<EOF > helm-values.yaml
---
applicationName: demo-gemfire
deployment:
  image:
    repository: ghcr.io/making/demo-gemfire
    tag: jvm
    pullPolicy: Always
  ports:
  - name: http
    containerPort: 8080
    protocol: TCP
  env:
    gemfire.locators:
      value: demo-locator-0.demo-locator.demo.svc.cluster.local:10334,demo-locator-1.demo-locator.demo.svc.cluster.local:10334
    gemfire.properties.ssl-enabled-components:
      value: all
    gemfire.properties.ssl-endpoint-identification-enabled:
      value: "true"
    gemfire.properties.ssl-keystore:
      value: /certs/truststore.p12
    gemfire.properties.ssl-keystore-password:
      valueFrom:
        secretKeyRef:
          name: demo-cert
          key: password
    gemfire.properties.ssl-truststore:
      value: /certs/keystore.p12
    gemfire.properties.ssl-truststore-password:
      valueFrom:
        secretKeyRef:
          name: demo-cert
          key: password
  volumeMounts:
    cert-volume:
      mountPath: /certs
  volumes:
    cert-volume:
      secret:
        secretName: demo-cert
  resources:
    limits:
      cpu:
      memory: 768Mi
    requests:
      cpu:
      memory: 768Mi
  livenessProbe:
    enabled: true
    httpGet:
      path: /actuator/health/liveness
      port: 8080
      scheme: HTTP
  readinessProbe:
    enabled: true
    httpGet:
      path: /actuator/health/readiness
      port: 8080
      scheme: HTTP
  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: false
    runAsNonRoot: true
    runAsUser: 1002
    seccompProfile:
      type: RuntimeDefault
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - podAffinityTerm:
          labelSelector:
            matchLabels:
              app.kubernetes.io/part-of: demo-gemfire
          topologyKey: kubernetes.io/hostname
        weight: 1
ingress:
  enabled: true
  annotations:
    projectcontour.io/tls-cert-namespace: projectcontour
  hosts:
  - host: demo-gemfire.lan.ik.am
    paths:
    - path: /
      pathType: Prefix
  tls:
  - hosts:
    - demo-gemfire.lan.ik.am
    secretName: default-tls
---
EOF
```

> [!NOTE]
> この`helm-values.yaml`を使って次の`helm template`コマンドで生成されるYAMLは https://gist.github.com/making/3d32b0ac35ece4ac7f3ef70f168e58f2 です。
>
> ```bash
> helm template demo-gemfire stakater/application -n demo -f helm-values.yaml
> ```

次のコマンドでデプロイします：

```bash
helm upgrade --install demo-gemfire stakater/application -n demo -f helm-values.yaml --wait
```

Ingressに設定したドメイン（この例では`https://demo-gemfire.lan.ik.am`）にアクセスすると、次の画面が表示されます：

![image](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/1852/30faf48a-c5dc-4c4e-b6e4-098b504e01ae.png)

適当に顧客情報を登録します。

![image](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/1852/ceb8b86b-fb20-44fe-9072-94f0f149df8f.png)

![image](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/1852/15c63a87-cac7-4bd0-913d-abafb14ae03c.png)

UI上に登録した顧客情報が表示されます。gfshで確認しても、登録した顧客情報がRegionに保存されていることがわかります：


```bash
gfsh>query --query="SELECT * FROM /Customers"
Result : true
Limit  : 100
Rows   : 2

id | name
-- | -------------
2  | Ichiro Suzuki
1  | Taro Yamada
```

### クリーンアップ

アプリケーションを削除します。

```bash
helm delete -n demo demo-gemfire --wait
```

GemFireClusterを削除します。

```bash
kubectl delete -f /tmp/demo-gemfire.yaml -n demo
kubectl delete -f /tmp/demo-locator-management-api.yaml -n demo
```

GemFire OperatorとCRDを削除します。

```bash
helm delete -n gemfire-system gemfire-operator --wait
helm delete -n gemfire-system gemfire-crd --wait
```

---

Tanzu GemFire on Kubernetesのインストールと、Javaアプリケーションからの接続までの一連の流れを紹介しました。GemFire Operatorを使用することで、Kubernetes上でのGemFireクラスターの管理が容易になり、アプリケーション開発者はGemFireの機能を簡単に利用できるようになります。
デフォルトでTLSが有効になっているため、セキュリティも強化されて、プロダクションで使う場合に安心です。