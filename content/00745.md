---
title: Spring IntegrationによるPollingベースのOutboxパターンを実装する

tags: ["Spring Boot", "Spring Integration", "Java", "Outbox"]
categories: ["Programming", "Java", "org", "springframework", "integration", "jdbc"]
---

この記事ではSpring IntegrationでPollingベースのOutboxパターンを実装する方法を紹介します。

**目次**
<!-- toc -->

### Outboxパターンとは

[Outboxパターン](https://microservices.io/patterns/data/transactional-outbox.html) (正確には "Transactional outbox" )はChris Richardsonがまとめた[マイクロサービスパターン](https://microservices.io/patterns/index.html)の一つです。

> 以下の書籍で詳しく説明されています<br>
> [![マイクロサービスパターン](https://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=4295008583&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=ikam-22&language=ja_JP)](https://www.amazon.co.jp/dp/4295008583?&linkCode=ll1&tag=ikam-22&linkId=fc242fe990b15216c9bbc30f6258f62e&language=ja_JP&ref_=as_li_ss_tl)
> [マイクロサービスパターン 実践的システムデザインのためのコード解説](https://www.amazon.co.jp/dp/4295008583?&linkCode=ll1&tag=ikam-22&linkId=fc242fe990b15216c9bbc30f6258f62e&language=ja_JP&ref_=as_li_ss_tl)

ある処理からデータベースの更新**と**Message Broker(RabbitMQ, Kafkaなど)へのメッセージ送信を行う場合に、"Atomicity"(原子性)を保つための実装パターンです。2 Phase Commitを行わない前提です。


Outboxパターンを使わずにデータベースの更新とMessage Brokerへのメッセージ送信を行うとどうなるでしょうか。以下の2つのパターンが考えられます。

1. データベースのトランザクションをコミットしてからMessage Brokerへメッセージ送信
1. Message Brokerへメッセージ送信してからデータベースのトランザクションをコミット

先にデータベースのコミットを行う場合、次の図のように、コミット後にメッセージの送信が失敗すると、データベースの更新だけが確定されてしまいます。

<img width="725" alt="image" src="https://github.com/making/blog.ik.am/assets/106908/839d1304-0031-412c-804a-1b6e745830aa">

また、メッセージを送信してからデータベースのトランザクションを行う場合、次の図のように、メッセージ送信後にトランザクションのコミットに失敗すると、メッセージだけが送信されてしまいます。

<img width="725" alt="image" src="https://github.com/making/blog.ik.am/assets/106908/094b962c-70d0-4aa8-bbe0-3cd5d1b8a197">

このような問題を解決するために、データベースを更新したならメッセージも必ず(少なくとも)一回送信されることを保証できるよう次の図のように実装するのがOutboxパターンです。

<img width="745" alt="image" src="https://github.com/making/blog.ik.am/assets/106908/28622d4b-f0b0-43f5-9675-f9eb0dc66e95">

Outboxパターンではデータベース書き込み時にはメッセージの送信は行わず、代わりに同じデーターベース内の"outbox"と呼ばれるテーブルにメッセージ送信したい内容をINSERTします。
outboxテーブルへの書き込みは主処理と同一トランザクション内で行われるので、原子性は担保されます。

outboxに書き込まれた情報は"Message Relay"と呼ばれる処理で読み取られ、Message Brokerへメッセージ送信されます。
読み取った情報は削除されます。メッセージ送信後にトランザクションがコミットされれば、outboxにデータが書き込まれれば、少なくとも一回はメッセージを送信できることを保証できます。
トランザクションのコミットに失敗する場合は、outboxにデータが残るため、再びMessage Relayによる処理が行われて、メッセージが再送信される可能性があります。
したがって、メッセージ受信側は1回以上メッセージを受信することを念頭に冪等性を意識する必要があります。


outboxテーブルからメッセージを読み取る方法でOutboxパターンのアークテクチャーが変わります。
[マイクロサービスパターン](https://microservices.io/patterns/data/transactional-outbox.html)では読み取り方法として

* [Transaction logベース (Transaction log tailing)](https://microservices.io/patterns/data/transaction-log-tailing.html)
* [Pollingベース (Polling publisher)](https://microservices.io/patterns/data/polling-publisher.html)

の2種類が説明されています。

Transaction logベースの手法は、PostgreSQLのWAL (Write Ahead Log)やMySQLのbinlog、あるいはAWS DynamoDB table streamsなどを利用して、outboxの変更をデータベース側で検知します。
この手法を使った有名なライブラリとして[Debezium](https://debezium.io/)がよく知られています。

この手法は、後述のPollingベースの手法よりも良いパフォーマンスが期待できます。一方で、データベース製品毎に異なる特別な設定が必要（あるいは特別な機能を持つデータベースが必要）だったり、Debeziumのようなライブラリ導入のコストがかかります。

Pollingベースの手法は、次の図のようにシンプルにoutboxテーブルを定期的にselectして新しいレコードが追加されていないか確認します。処理済みのデータはdeleteします。
SQLだけで実装できるのでデータベースの特別な設定が不要で、シンプルに実装できます。一方、定期的にoutboxテーブルに対してselectを実行するため、データベースへの負荷が大きく、パフォーマンスに影響を及ぼす可能性があります。


<img width="745" alt="image" src="https://github.com/making/blog.ik.am/assets/106908/d08dd1a5-f11e-4ec4-916b-a7df5afb0583">

本記事では後者のPollingベースによるOutboxパターンを使用します。

### Spring IntegrationによるOutboxパターン
Spring IntegrationのリードであるArtem BilanによるBlog Post"[Introducing Microservices Patterns with Spring Integration](https://spring.io/blog/2023/01/25/introducing-microservices-patterns-with-spring-integration)"にて、Spring IntegrationでOutboxパターンを実装するサンプルが紹介されました。

サンプルのソースコードは以下です。Spring IntegrationだけでシンプルにOutboxパターンが実装できています。<br>
https://github.com/artembilan/microservices-patterns-spring-integration/tree/main/outbox


Spring Integrationはメッセージングの抽象化フレームワークです。EndpointをMessageChannelで繋いでフローを定義し、Messageを送受信できます。
InboundとなるEndpointから送られたMessageがMessageChannelへ送られ、Endpointで処理され、またMessageChanelに渡され、OutboundのEndpointで送信されます。

Spring Integrationで次のようなフローを定義すればOutboxパターンを実装できます。図の四角がEndpoint、筒がMessageChannelです（上の図では筒がMessage Brokerを表現していたので紛らわしいかもしれません...）。
![image](https://github.com/making/blog.ik.am/assets/106908/5302441f-7530-422b-8055-4af348fd36e3)

ここでポイントとなるのが"outbox"と名付けられたMessageChannelです。

[MessageChannel](https://docs.spring.io/spring-integration/docs/current/reference/html/core.html#channel)はデフォルトではインメモリでMessageを伝送しますが、[JdbcChannelMessageStore](https://docs.spring.io/spring-integration/docs/current/reference/html/jdbc.html#jdbc-message-store-channels)を使ってMessageChannelのバックエンドにJDBCを使用することもできます。
このMessageChannelはPollableな[QueueChannel](https://docs.spring.io/spring-integration/docs/current/reference/html/core.html#channel-implementations-queuechannel)実装です。

このMessageChannelがまさに"outbox"テーブルとして利用可能です。実体としては[`INT_CHANNEL_MESSAGE`](https://github.com/spring-projects/spring-integration/blob/main/spring-integration-jdbc/src/main/resources/org/springframework/integration/jdbc/schema-postgresql.sql#L39-L48)テーブルが[マイクロサービスパターン](https://microservices.io/patterns/data/transactional-outbox.html)"outbox"テーブルに相当します。
Spring Integrationを使用すれば、Outboxパターンにおけるoutboxへのメッセージの書き込みとoutboxからのメッセージのpollingはMessageChannelで隠蔽されており、実装する必要がありません。
あとは下の図のようにビジネスロジックとoutboxへの書き込み、および、outboxからのメッセージの取り出しとMessage Brokerへメッセージ送信処理(Message Relay)をそれぞれ同一トランザクション内で行われるようにSpring Integrationのフローを定義すればOutboxパターンが実装できます。

![image](https://github.com/making/blog.ik.am/assets/106908/de7933a1-8ca0-4f7a-b072-4ab8f9815129)


### サンプルアプリの実装

上記のフローを利用したサンプルアプリを実装してみました。下の図のようにOrder Serviceはメッセージブローカーを経由してShipment Serviceへメッセージを送信します。それと同時にOrder DBへの更新も行います。この二つの更新をOutboxパターンで実装合います。

今回はメッセージブローカーに、セットアップが容易なRabbitMQを利用しました。

> ℹ️ 後述するように、今回のデモのようなケースではパーティションニングに対応したメッセージブローカーを使用した方が適切で、[RabbitMQ Streams](https://www.rabbitmq.com/streams.html)の[Super Streams](https://www.rabbitmq.com/streams.html#super-streams)(あるいはKafka)を使った方が良かったのですが、<br>
> Observailityの対応の関係で普通のRabbitMQを使用しました。

<img width="745" alt="image" src="https://github.com/making/blog.ik.am/assets/106908/d316fbde-058e-45b6-9498-c7e1f06144a2">

WIP

https://github.com/making/outbox-pattern-demo

