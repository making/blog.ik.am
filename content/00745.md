---
title: Spring IntegrationによるPollingベースのOutboxパターンを実装する

tags: ["Spring Boot", "Spring Integration", "Java", "Outbox"]
categories: ["Programming", "Java", "org", "springframework", "integration", "jdbc"]
---

この記事ではSpring IntegrationでPollingベースのOutboxパターンを実装する方法を紹介します。

**目次**
<!-- toc -->

### Outboxパターンとは

[Outboxパターン](https://microservices.io/patterns/data/transactional-outbox.html) (正確には "Transactional outbox" )はChris Richardsonがまとめた[マイクロサービスパターン](https://microservices.io/patterns/index.html)の一つです。

> 以下の書籍で詳しく説明されています<br>
> [![マイクロサービスパターン](https://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=4295008583&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=ikam-22&language=ja_JP)](https://www.amazon.co.jp/dp/4295008583?&linkCode=ll1&tag=ikam-22&linkId=fc242fe990b15216c9bbc30f6258f62e&language=ja_JP&ref_=as_li_ss_tl)
> [マイクロサービスパターン 実践的システムデザインのためのコード解説](https://www.amazon.co.jp/dp/4295008583?&linkCode=ll1&tag=ikam-22&linkId=fc242fe990b15216c9bbc30f6258f62e&language=ja_JP&ref_=as_li_ss_tl)

ある処理からデータベースの更新**と**Message Broker(RabbitMQ, Kafkaなど)へのメッセージ送信を行う場合に、"Atomicity"(原子性)を保つための実装パターンです。2 Phase Commitを行わない前提です。


Outboxパターンを使わずにデータベースの更新とMessage Brokerへのメッセージ送信を行うとどうなるでしょうか。以下の2つのパターンが考えられます。

1. データベースのトランザクションをコミットしてからMessage Brokerへメッセージ送信
1. Message Brokerへメッセージ送信してからデータベースのトランザクションをコミット

先にデータベースのコミットを行う場合、次の図のように、コミット後にメッセージの送信が失敗すると、データベースの更新だけが確定されてしまいます。

<img width="725" alt="image" src="https://github.com/making/blog.ik.am/assets/106908/839d1304-0031-412c-804a-1b6e745830aa">

また、メッセージを送信してからデータベースのトランザクションを行う場合、次の図のように、メッセージ送信後にトランザクションのコミットに失敗すると、メッセージだけが送信されてしまいます。

<img width="725" alt="image" src="https://github.com/making/blog.ik.am/assets/106908/094b962c-70d0-4aa8-bbe0-3cd5d1b8a197">

このような問題を解決するために、データベースを更新したならメッセージも必ず(少なくとも)一回送信されることを保証できるよう次の図のように実装するのがOutboxパターンです。

<img width="745" alt="image" src="https://github.com/making/blog.ik.am/assets/106908/28622d4b-f0b0-43f5-9675-f9eb0dc66e95">

Outboxパターンではデータベース書き込み時にはメッセージの送信は行わず、代わりに同じデーターベース内の"outbox"と呼ばれるテーブルにメッセージ送信したい内容をINSERTします。
outboxテーブルへの書き込みは主処理と同一トランザクション内で行われるので、原子性は担保されます。

outboxに書き込まれた情報は"Message Relay"と呼ばれる処理で読み取られ、Message Brokerへメッセージ送信されます。
読み取った情報は削除されます。メッセージ送信後にトランザクションがコミットされれば、outboxにデータが書き込まれれば、少なくとも一回はメッセージを送信できることを保証できます。
トランザクションのコミットに失敗する場合は、outboxにデータが残るため、再びMessage Relayによる処理が行われて、メッセージが再送信される可能性があります。
したがって、メッセージ受信側は1回以上メッセージを受信することを念頭に冪等性を意識する必要があります。


outboxテーブルからメッセージを読み取る方法でOutboxパターンのアークテクチャーが変わります。
[マイクロサービスパターン](https://microservices.io/patterns/data/transactional-outbox.html)では読み取り方法として

* [Transaction logベース (Transaction log tailing)](https://microservices.io/patterns/data/transaction-log-tailing.html)
* [Pollingベース (Polling publisher)](https://microservices.io/patterns/data/polling-publisher.html)

の2種類が説明されています。

Transaction logベースの手法は、PostgreSQLのWAL (Write Ahead Log)やMySQLのbinlog、あるいはAWS DynamoDB table streamsなどを利用して、outboxの変更をデータベース側で検知します。
この手法を使った有名なライブラリとして[Debezium](https://debezium.io/)がよく知られています。

この手法は、後述のPollingベースの手法よりも良いパフォーマンスが期待できます。一方で、データベース製品毎に異なる特別な設定が必要（あるいは特別な機能を持つデータベースが必要）だったり、Debeziumのようなライブラリ導入のコストがかかります。

Pollingベースの手法は、次の図のようにシンプルにoutboxテーブルを定期的にselectして新しいレコードが追加されていないか確認します。処理済みのデータはdeleteします。
SQLだけで実装できるのでデータベースの特別な設定が不要で、シンプルに実装できます。一方、定期的にoutboxテーブルに対してselectを実行するため、データベースへの負荷が大きく、パフォーマンスに影響を及ぼす可能性があります。


<img width="745" alt="image" src="https://github.com/making/blog.ik.am/assets/106908/d08dd1a5-f11e-4ec4-916b-a7df5afb0583">

本記事では後者のPollingベースによるOutboxパターンを使用します。

### Spring IntegrationによるOutboxパターン
Spring IntegrationのリードであるArtem BilanによるBlog Post"[Introducing Microservices Patterns with Spring Integration](https://spring.io/blog/2023/01/25/introducing-microservices-patterns-with-spring-integration)"にて、Spring IntegrationでOutboxパターンを実装するサンプルが紹介されました。

サンプルのソースコードは以下です。Spring IntegrationだけでシンプルにOutboxパターンが実装できています。<br>
https://github.com/artembilan/microservices-patterns-spring-integration/tree/main/outbox


Spring Integrationはメッセージングの抽象化フレームワークです。EndpointをMessageChannelで繋いでフローを定義し、Messageを送受信できます。
InboundとなるEndpointから送られたMessageがMessageChannelへ送られ、Endpointで処理され、またMessageChanelに渡され、OutboundのEndpointで送信されます。

Spring Integrationで次のようなフローを定義すればOutboxパターンを実装できます。図の四角がEndpoint、筒がMessageChannelです（上の図では筒がMessage Brokerを表現していたので紛らわしいかもしれません...）。
![image](https://github.com/making/blog.ik.am/assets/106908/5302441f-7530-422b-8055-4af348fd36e3)

ここでポイントとなるのが"outbox"と名付けられたMessageChannelです。

[MessageChannel](https://docs.spring.io/spring-integration/docs/current/reference/html/core.html#channel)はデフォルトではインメモリでMessageを伝送しますが、[JdbcChannelMessageStore](https://docs.spring.io/spring-integration/docs/current/reference/html/jdbc.html#jdbc-message-store-channels)を使ってMessageChannelのバックエンドにJDBCを使用することもできます。
このMessageChannelはPollableな[QueueChannel](https://docs.spring.io/spring-integration/docs/current/reference/html/core.html#channel-implementations-queuechannel)実装です。

このMessageChannelがまさに"outbox"テーブルとして利用可能です。実体としては[`INT_CHANNEL_MESSAGE`](https://github.com/spring-projects/spring-integration/blob/main/spring-integration-jdbc/src/main/resources/org/springframework/integration/jdbc/schema-postgresql.sql#L39-L48)テーブルが[マイクロサービスパターン](https://microservices.io/patterns/data/transactional-outbox.html)"outbox"テーブルに相当します。
Spring Integrationを使用すれば、Outboxパターンにおけるoutboxへのメッセージの書き込みとoutboxからのメッセージのpollingはMessageChannelで隠蔽されており、実装する必要がありません。
あとは下の図のようにビジネスロジックとoutboxへの書き込み、および、outboxからのメッセージの取り出しとMessage Brokerへメッセージ送信処理(Message Relay)をそれぞれ同一トランザクション内で行われるようにSpring Integrationのフローを定義すればOutboxパターンが実装できます。

![image](https://github.com/making/blog.ik.am/assets/106908/de7933a1-8ca0-4f7a-b072-4ab8f9815129)


### サンプルアプリの実装

上記のフローを利用したサンプルアプリを実装してみました。下の図のようにOrder Serviceはメッセージブローカーを経由してShipment Serviceへメッセージを送信します。それと同時にOrder DBへの更新も行います。この二つの更新をOutboxパターンで実装合います。

今回はメッセージブローカーに、セットアップが容易なRabbitMQを利用しました。

> ℹ️ 後述するように、今回のデモのようなケースではパーティションニングに対応したメッセージブローカーを使用した方が適切で、[RabbitMQ Streams](https://www.rabbitmq.com/streams.html)の[Super Streams](https://www.rabbitmq.com/streams.html#super-streams)(あるいはKafka)を使った方が良かったのですが、<br>
> Observailityの対応の関係で普通のRabbitMQを使用しました。

<img width="745" alt="image" src="https://github.com/making/blog.ik.am/assets/106908/f654bf75-fa67-48dc-b5fa-fdafe1b50da6">

サンプルコードは<br>
https://github.com/making/outbox-pattern-demo
です。Debeziumの[outboxサンプル](https://github.com/debezium/debezium-examples/tree/main/outbox)も参考にしました。
<br>


フローの入り口となるGatewayとして、次のインタフェースを定義します。注文処理を行う`placeOrder`と注文をキャンセルする`cancelOrder`メソッドがあります。

`placeOrder`は双方向のメッセージングで入力が`order.create`チャネルに送られ、出力が`order.create.reply`から返ります。`cancelOrder`は一方向のメッセージングで、入力が`order.cancel`チャネルに送られ、出力はありません。


```java
@MessagingGateway
public interface OrderGateway {

	@Gateway(requestChannel = "order.create", replyChannel = "order.create.reply")
	Order placeOrder(Order order);

	@Gateway(requestChannel = "order.cancel")
	void cancelOrder(Long orderId);

}
```

Gatewayへの入力は次のようにシンプルに`@RestController`で実装します。

```java
@RestController
public class OrderController {

	private final OrderGateway orderGateway;

	private final Clock clock;

	private final Logger log = LoggerFactory.getLogger(OrderController.class);

	public OrderController(OrderGateway orderGateway, Clock clock) {
		this.orderGateway = orderGateway;
		this.clock = clock;
	}

	@PostMapping(path = "/orders")
	public Order placeOrder(@RequestBody OrderRequest orderRequest) {
		final Order newOrder = orderRequest.newOrder(this.clock);
		final Order order = this.orderGateway.placeOrder(newOrder);
		log.info("Created {}", order);
		return order;
	}

	@DeleteMapping(path = "/orders/{orderId}")
	public void cancelOrder(@PathVariable Long orderId) {
		this.orderGateway.cancelOrder(orderId);
		log.info("Cancelled {}", orderId);
	}

}
```

OrderをOrder DBに保存したり、更新したりする処理は次の`OrderService`と`OrderRepository`で行います。

```java
@Service
@Transactional
@Observed
public class OrderService {

	private final OrderRepository orderRepository;

	public OrderService(OrderRepository orderRepository) {
		this.orderRepository = orderRepository;
	}

	public Order create(Order order) {
		return this.orderRepository.save(order);
	}

	public int cancel(Long orderId) {
		return this.orderRepository.updateStatus(orderId, OrderStatus.CANCELLED);
	}

}
```

```java
public interface OrderRepository extends ListCrudRepository<Order, Long> {

	@Modifying
	@Query("UPDATE Order SET status=:status WHERE orderId=:orderId AND status <> :status")
	int updateStatus(Long orderId, OrderStatus status);

}
```


`order.create`チャネルからの`outbox`までのメッセージングのフローを次のように定義します。

```java
@Bean
public IntegrationFlow orderCreateFlow(OrderService orderService) {
	return IntegrationFlow.from("order.create")
		.routeToRecipients(routes -> routes.transactional() // (1)
			.recipientFlow(f -> f.<Order>handle((order, headers) -> orderService.create(order)) // (2)
				.channel(c -> c.publishSubscribe("order.create.reply")) // (3)
				.transform(OrderEvents.Created::from) // (4)
				.enrichHeaders(h -> h.header("eventType", "order_created")) // (5)
				.channel("outbox"))) // (6)
		.get();
}
```

| 番号 | 説明 |
| -- | -- |
| (1) | [Artemのサンプル](https://github.com/artembilan/microservices-patterns-spring-integration/tree/main/outbox)のように[Recipient List Router](https://docs.spring.io/spring-integration/docs/current/reference/html/message-routing.html#router-implementations-recipientlistrouter)のトランザクション処理を使用して、`order.create`チャネルからメッセージを受信して、`outbox`チャネルに送信するまでの処理が同一トランザクション上で行われるようになります。 |
| (2) | `OrderService#create` を呼び出すだけのMesageHandlerを作成します。 |
| (3) | (2)のEndpointの出力チャネルからのメッセージをGatewayのreplyとフローの次のEndpoint(`transform`)へ同時に送れるようにPub/Sub型のMessageChannelを定義し、`order.create.reply`と名付けます。デフォルトのMessageChannel実装である`DirectChannel`は同時に1つのSubscriberしかメッセージが送信されない(round-robbinされる)ので、複数のSubscriberに対応した`PublishSubscribeChannel`を使用します。 |
| (4) | (2)のEndpointの結果のメッセージのPayloadを`Order`インスタンスからShipment Serviceに送る`OrderEvents.Created`インスタンスに変換します。 |
| (5) | eventTypeをヘッダーに設定します。 |
| (6) | (5)のEndpointの出力チャネルを`outbox`(後に定義)にします。 |

`outbox`チャネルからAMQP(RabbitMQ)へ送信するまでのフローを次のように定義します。

```java
@Bean
public IntegrationFlow messageRelayFlow(MessageHandler amqpHandler) {
	return IntegrationFlow.from("outbox")
		.handle(amqpHandler, e -> e.poller(poller -> poller.fixedDelay(3_000, 3_000).transactional())) // (1)
		.get();
}

@Bean
public MessageHandler amqpHandler(AmqpTemplate amqpTemplate, ObjectMapper objectMapper) {
	final MessageHandler messageHandler = Amqp.outboundAdapter(amqpTemplate)
		.exchangeName("order")
		.routingKey("event")
		.getObject(); // (2)
	final Logger log = LoggerFactory.getLogger("amqpHandler");
	return message -> { // (3)
		final JsonNode payload = objectMapper.convertValue(message.getPayload(), JsonNode.class);
		log.info("Send {}", payload);
		messageHandler.handleMessage(MessageBuilder.createMessage(payload, message.getHeaders()));
	};
}
```

| 番号 | 説明 |
| -- | -- |
| (1) | `outbox`チャネルからメッセージを受信して`amqpHandler`で処理します。`outbox`からの受信はPollingで行い、Polling間隔は3000msです。`transactional()`を設定することで、`outbox`からのメッセージのselectおよびdeleteとMeeageHandlerの処理は同一トランザクション上で行われます。 |
| (2) | AMQP(RabbitMQ)へメッセージを送信するMessageHandelerを定義します。 |
| (3) | (2)のMessageHandelerに対して、受信側が扱いやすいように`JsonNode`型にPayloadを変換する処理をラップして返します。 |


[JdbcChannelMessageStore](https://docs.spring.io/spring-integration/docs/current/reference/html/jdbc.html#jdbc-message-store-channels)を使った`outbox`チャネルの定義は次のとおりです。

```java
@Bean
public JdbcChannelMessageStore jdbcChannelMessageStore(DataSource dataSource) {
	final JdbcChannelMessageStore jdbcChannelMessageStore = new JdbcChannelMessageStore(dataSource);
	jdbcChannelMessageStore.setChannelMessageStoreQueryProvider(new PostgresChannelMessageStoreQueryProvider());
	return jdbcChannelMessageStore;
}

@Bean
public QueueChannel outbox(JdbcChannelMessageStore jdbcChannelMessageStore) {
	return MessageChannels.queue(jdbcChannelMessageStore, "outbox").getObject();
}
```

同様にして`order.create`チャネルからの`outbox`までのメッセージングのフローは次のように定義できます。

```java
@Bean
public IntegrationFlow orderCancelFlow(OrderService orderService, Clock clock) {
	return IntegrationFlow.from("order.cancel")
		.routeToRecipients(
				routes -> routes.transactional().recipientFlow(f -> f.<Long>handle((orderId, headers) -> {
					final int updated = orderService.cancel(orderId);
					return updated > 0 ? orderId : null; // (1)
				}).<Long, OrderEvents
						.Cancelled>transform(
								orderId -> new OrderEvents.Cancelled(orderId,
										clock.instant().atOffset(ZoneOffset.UTC))) // (2)
					.enrichHeaders(h -> h.header("eventType", "order_cancelled"))
					.channel("outbox")))
		.get();
}
```

| 番号 | 説明 |
| -- | -- |
| (1) | `OrderService#cancel` を呼び出すのMesageHandlerを作成します。更新件数が0、つまり更新対象が存在しない場合はメッセージを破棄します。 |
| (2) | (2)のEndpointの結果のメッセージのPayloadを`Order`インスタンスからShipment Serviceに送る`OrderEvents.Cancelled`インスタンスに変換します。 |


ここまでのフローを図示すると、次の図のようになります(`enrichHeaders`のEndpointは省略してあります)。

![image](https://github.com/making/blog.ik.am/assets/106908/58f4fb75-24db-4869-a024-4e7c68ef77eb)


WIP


