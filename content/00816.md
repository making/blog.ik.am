---
title: Spring BootでmTLS(Mutual TLS)の設定メモ
tags: ["Java", "Spring Boot", "Spring Security", "mTLS", "TLS"]
categories: ["Programming", "Java", "org", "springframework", "security", "web", "authentication", "preauth", "x509"]
---

**目次**
<!-- toc -->

### サンプルプロジェクトの作成

```bash
curl https://start.spring.io/starter.tgz \
       -d artifactId=demo-mtls \
       -d baseDir=demo-mtls \
       -d packageName=com.example \
       -d dependencies=web,actuator,security \
       -d type=maven-project \
       -d name=demo-mtls \
       -d applicationName=DemoMtlsApplication | tar -xzvf -
cd demo-mtls
```

`pom.xml`

```xml
                <!--
                <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-starter-security</artifactId>
                </dependency>
                -->
```

```
./mvnw clean package -DskipTests
```

```
java -jar target/demo-mtls-0.0.1-SNAPSHOT.jar
```

```
$ curl http://localhost:8080/actuator/health
{"status":"UP"}
```

### サーバー側でHTTPSを有効にする (One-way TLS)

```bash
DIR=$PWD/src/main/resources/self-signed
mkdir -p ${DIR}

# Create CA certificate
openssl req -new -nodes -out ${DIR}/ca.csr -keyout ${DIR}/ca.key -subj "/CN=@making/O=LOL.MAKI/C=JP"
chmod og-rwx ${DIR}/ca.key

cat <<EOF > ${DIR}/ext_ca.txt
basicConstraints=CA:TRUE
keyUsage=digitalSignature,keyCertSign
EOF

openssl x509 -req -in ${DIR}/ca.csr -days 3650 -signkey ${DIR}/ca.key -out ${DIR}/ca.crt -extfile ${DIR}/ext_ca.txt

cat <<EOF > ${DIR}/ext.txt
basicConstraints=CA:FALSE
keyUsage=digitalSignature,dataEncipherment,keyEncipherment,keyAgreement
extendedKeyUsage=serverAuth,clientAuth
EOF

# Create Server certificate signed by CA
openssl req -new -nodes -out ${DIR}/server.csr -keyout ${DIR}/server.key -subj "/CN=localhost"
chmod og-rwx ${DIR}/server.key
openssl x509 -req -in ${DIR}/server.csr -days 3650 -CA ${DIR}/ca.crt -CAkey ${DIR}/ca.key -CAcreateserial -out ${DIR}/server.crt -extfile ${DIR}/ext.txt
```


```
$ ls -l src/main/resources/self-signed
total 72
-rw-r--r--  1 tmaki  staff  1164  8 27 10:42 ca.crt
-rw-r--r--  1 tmaki  staff   932  8 27 10:42 ca.csr
-rw-------  1 tmaki  staff  1704  8 27 10:42 ca.key
-rw-r--r--  1 tmaki  staff    41  8 27 10:42 ca.srl
-rw-r--r--  1 tmaki  staff   137  8 27 10:42 ext.txt
-rw-r--r--  1 tmaki  staff    63  8 27 10:42 ext_ca.txt
-rw-r--r--  1 tmaki  staff  1204  8 27 10:42 server.crt
-rw-r--r--  1 tmaki  staff   891  8 27 10:42 server.csr
-rw-------  1 tmaki  staff  1704  8 27 10:42 server.key
```

```
./mvnw clean package -DskipTests
```


```properties
cat <<EOF > src/main/resources/application-tls.properties
server.port=8443
server.ssl.enabled=true
server.ssl.bundle=self-signed
spring.ssl.bundle.pem.self-signed.keystore.certificate=classpath:self-signed/server.crt
spring.ssl.bundle.pem.self-signed.keystore.private-key=classpath:self-signed/server.key
EOF
```

```
./mvnw clean package -DskipTests
```

```
java -jar target/demo-mtls-0.0.1-SNAPSHOT.jar --spring.profiles.active=tls
```

```
$ curl -k https://localhost:8443/actuator/health
{"status":"UP"}
```

```
$ curl --cacert src/main/resources/self-signed/ca.crt https://localhost:8443/actuator/health
{"status":"UP"}
```

```
$ curl --cacert src/main/resources/self-signed/ca.crt https://localhost:8443/actuator/health -v
...
* ALPN: curl offers h2,http/1.1
* TLSv1.2 (OUT), TLS handshake, Client hello (1):
*  CAfile: src/main/resources/self-signed/ca.crt
*  CApath: none
...
* Server certificate:
*  subject: CN=localhost
*  start date: Aug 27 01:42:54 2024 GMT
*  expire date: Aug 25 01:42:54 2034 GMT
*  common name: localhost (matched)
*  issuer: CN=@making; O=LOL.MAKI; C=JP
*  SSL certificate verify ok.
* using HTTP/1.x
...
{"status":"UP"}
```

```properties
cat <<EOF > src/main/resources/application-mtls.properties
server.ssl.client-auth=need
spring.ssl.bundle.pem.self-signed.truststore.certificate=classpath:self-signed/ca.crt
EOF
```

```
./mvnw clean package -DskipTests
```

```
java -jar target/demo-mtls-0.0.1-SNAPSHOT.jar --spring.profiles.active=tls,mtls
```

```
$ curl --cacert src/main/resources/self-signed/ca.crt https://localhost:8443/actuator/health   
curl: (56) BoringSSL SSL_read: BoringSSL: error:10000412:SSL routines:OPENSSL_internal:SSLV3_ALERT_BAD_CERTIFICATE, errno 0
```

### クライアント証明も要求する (Mutual TLS)

```bash
DIR=$PWD/src/main/resources/self-signed
# Create Client certificate signed by CA
openssl req -new -nodes -out ${DIR}/client.csr -keyout ${DIR}/client.key -subj "/CN=toshiaki-maki"
chmod og-rwx ${DIR}/client.key
openssl x509 -req -in ${DIR}/client.csr -days 3650 -CA ${DIR}/ca.crt -CAkey ${DIR}/ca.key -CAcreateserial -out ${DIR}/client.crt -extfile ${DIR}/ext.txt
```

```
$ openssl x509 -noout -text -in src/main/resources/self-signed/client.crt 
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            72:52:05:2b:43:f7:d8:6a:23:95:50:65:19:d0:be:38:0e:e9:82:ed
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=@making, O=LOL.MAKI, C=JP
        Validity
            Not Before: Aug 27 01:56:49 2024 GMT
            Not After : Aug 25 01:56:49 2034 GMT
        Subject: CN=toshiaki-maki
...
```

```
$ curl --cacert src/main/resources/self-signed/ca.crt --cert src/main/resources/self-signed/client.crt --key src/main/resources/self-signed/client.key https://localhost:8443/actuator/health
{"status":"UP"}   
```

### クライアントサイドのmTLS対応


```java
cat <<EOF > src/test/java/com/example/CertUtils.java
package com.example;

import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;

import org.springframework.core.io.DefaultResourceLoader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.util.StreamUtils;

public class CertUtils {

	private static final ResourceLoader resourceLoader = new DefaultResourceLoader();

	public static X509Certificate loadCertificate(String location) {
		Resource resource = resourceLoader.getResource(location);
		try (var stream = resource.getInputStream()) {
			CertificateFactory cf = CertificateFactory.getInstance("X.509");
			return (X509Certificate) cf.generateCertificate(stream);
		}
		catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	public static PrivateKey loadPrivateKey(String location) {
		Resource resource = resourceLoader.getResource(location);
		try (var stream = resource.getInputStream()) {
			String key = StreamUtils.copyToString(stream, StandardCharsets.UTF_8)
				.replace("-----BEGIN PRIVATE KEY-----", "")
				.replace("-----END PRIVATE KEY-----", "")
				.replace("\n", "");
			byte[] keyBytes = Base64.getDecoder().decode(key);
			PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
			KeyFactory kf = KeyFactory.getInstance("RSA");
			return kf.generatePrivate(spec);
		}
		catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	public static KeyStore createKeyStore(String privateKey, String certificate, String password) {
		return createKeyStore(loadPrivateKey(privateKey), loadCertificate(certificate), password);
	}

	public static KeyStore createEmptyKeyStore() {
		try {
			KeyStore keyStore = KeyStore.getInstance("PKCS12");
			keyStore.load(null, null);
			return keyStore;
		}
		catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	public static KeyStore createKeyStore(PrivateKey privateKey, X509Certificate certificate, String password) {
		try {
			KeyStore keyStore = KeyStore.getInstance("PKCS12");
			keyStore.load(null, null);
			KeyStore.PrivateKeyEntry privateKeyEntry = new KeyStore.PrivateKeyEntry(privateKey,
					new java.security.cert.Certificate[] { certificate });
			KeyStore.PasswordProtection passwordProtection = new KeyStore.PasswordProtection(password.toCharArray());
			keyStore.setEntry("key", privateKeyEntry, passwordProtection);
			return keyStore;
		}
		catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	public static KeyStore createTrustStore(String location) {
		try {
			KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
			trustStore.load(null, null);
			trustStore.setCertificateEntry("ca-cert", loadCertificate(location));
			return trustStore;
		}
		catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

}
EOF
```

```java
cat <<EOF > src/test/java/com/example/DemoMtlsApplicationTests.java
package com.example;

import java.net.http.HttpClient;
import java.security.KeyStore;

import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLHandshakeException;
import javax.net.ssl.TrustManagerFactory;

import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.client.JdkClientHttpRequestFactory;
import org.springframework.web.client.ResourceAccessException;
import org.springframework.web.client.RestClient;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.fail;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, properties = "spring.profiles.active=tls,mtls")
class DemoMtlsApplicationTests {
	@LocalServerPort int port;

	@Autowired RestClient.Builder restClientBuilder;

	@Test
	void healthCheckWithValidCertificate() {
		KeyStore keyStore = CertUtils.createKeyStore("classpath:self-signed/client.key", "classpath:self-signed/client.crt", "dummy");
		KeyStore trustStore = CertUtils.createTrustStore("classpath:self-signed/ca.crt");
		HttpClient httpClient = createHttpClient(keyStore, "dummy", trustStore);
		RestClient restClient = this.restClientBuilder
				.baseUrl("https://localhost:" + port)
				.requestFactory(new JdkClientHttpRequestFactory(httpClient))
				.build();
		ResponseEntity<String> response = restClient.get()
				.uri("/actuator/health")
				.retrieve()
				.toEntity(String.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(response.getBody()).isEqualTo("{\"status\":\"UP\"}");
	}

	@Test
	void healthCheckWithoutCertificate() {
		KeyStore keyStore = CertUtils.createEmptyKeyStore();
		KeyStore trustStore = CertUtils.createTrustStore("classpath:self-signed/ca.crt");
		HttpClient httpClient = createHttpClient(keyStore, "dummy", trustStore);
		RestClient restClient = this.restClientBuilder
				.baseUrl("https://localhost:" + port)
				.requestFactory(new JdkClientHttpRequestFactory(httpClient))
				.build();
		try {
			restClient.get()
					.uri("/actuator/health")
					.retrieve()
					.toEntity(String.class);
			fail("Should have thrown an exception");
		} catch (ResourceAccessException e) {
			assertThat(e.getCause()).isInstanceOf(SSLHandshakeException.class);
			assertThat(e.getCause().getMessage()).isEqualTo("Received fatal alert: bad_certificate");
		}
	}

	static HttpClient createHttpClient(KeyStore keyStore, String keyStorePassword, KeyStore trustStore) {
		try {
			KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
			kmf.init(keyStore, keyStorePassword.toCharArray());
			TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
			tmf.init(trustStore);
			SSLContext sslContext = SSLContext.getInstance("TLS");
			sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
			return HttpClient.newBuilder().sslContext(sslContext).build();
		}
		catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

}
EOF
```

```
./mvnw clean test
```

### Spring SecurityによるTLS認証・認可

```xml
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
```

```java
cat <<EOF > src/main/java/com/example/SecurityConfig.java
package com.example;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.SecurityFilterChain;

@Configuration(proxyBeanMethods = false)
public class SecurityConfig {
	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		return http
				.authorizeHttpRequests(authz -> authz
						.requestMatchers("/").hasRole("MTLS")
						.anyRequest().permitAll())
				.x509(s -> s.subjectPrincipalRegex("CN=([\\w\\-]+)"))
				.build();
	}

	@Bean
	public UserDetailsService userDetailsService() {
		return username -> User.withUsername(username).password("{noop}dummy").roles("MTLS").build();
	}
}
EOF
```

```java
	@Test
	void hello() {
		KeyStore keyStore = CertUtils.createKeyStore("classpath:self-signed/client.key", "classpath:self-signed/client.crt", "dummy");
		KeyStore trustStore = CertUtils.createTrustStore("classpath:self-signed/ca.crt");
		HttpClient httpClient = createHttpClient(keyStore, "dummy", trustStore);
		RestClient restClient = this.restClientBuilder
				.baseUrl("https://localhost:" + port)
				.requestFactory(new JdkClientHttpRequestFactory(httpClient))
				.build();
		ResponseEntity<String> response = restClient.get()
				.uri("/")
				.retrieve()
				.toEntity(String.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(response.getBody()).isEqualTo("Hello toshiaki-maki!");
	}
```

> [!TIP]
> `java.security.cert.X509Certificate`から柔軟にユーザーを作りたい場合は、`org.springframework.security.web.authentication.preauth.x509.X509PrincipalExtractor`にロジックを実装して、`.x509(s -> s.x509PrincipalExtractor(new MyExtractor()))`で設定できます。

```
./mvnw clean package
java -jar target/demo-mtls-0.0.1-SNAPSHOT.jar --spring.profiles.active=tls,mtls
```

```
$ curl --cacert src/main/resources/self-signed/ca.crt --cert src/main/resources/self-signed/client.crt --key src/main/resources/self-signed/client.key https://localhost:8443 
Hello toshiaki-maki!
```

```
$ curl --cacert src/main/resources/self-signed/ca.crt https://localhost:8443  
curl: (56) BoringSSL SSL_read: BoringSSL: error:10000412:SSL routines:OPENSSL_internal:SSLV3_ALERT_BAD_CERTIFICATE, errno 0
```

```
java -jar target/demo-mtls-0.0.1-SNAPSHOT.jar --spring.profiles.active=tls,mtls --server.ssl.client-auth=want
```


```
$ curl --cacert src/main/resources/self-signed/ca.crt https://localhost:8443 
{"timestamp":"2024-08-27T03:28:12.310+00:00","status":403,"error":"Forbidden","path":"/"}
```

